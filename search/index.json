[{"content":"For about 3 years I\u0026rsquo;ve been involved in a women in tech community that has the objective to increase the number of women participating in technology, and trying to achive this main objective I got the idea to start a blog project that gathers some of the brightest women I know as writers of this blog and that for a year will write a post about technology every week.\nI know most of those selected women for this project and the others that I didn\u0026rsquo;t know, I\u0026rsquo;ve been starting to see their talent. One of my favorite part of this project is that each one of the woman that are participating are really sharing what they know, what they like or even what they are implementing on their jobs, and I can noticed that each of them are growing on each of their career paths as well as they learn more about themselves. The other thing I love is how we have been created a real community improving all the posts written until now, because we\u0026rsquo;re not only writers, we\u0026rsquo;re also reviewers and we do comments to improve the redaction of every post.\nI think this is the most wonderful project that I\u0026rsquo;ve started with the organizer women in TechWo because this is the first time I think I\u0026rsquo;m doing the difference for the women that I want to motivate that are the programmers. TechWo is for every women involved in technology not only for programmers, but my expertise area in thechnology is programming and all related to software development, that\u0026rsquo;s why I\u0026rsquo;m so interested in share my knowledge trying to motivate other girls to do and love this amazing career that I think gives a lot for a few things.\nAll the posts of the blog are written in spanish since that is our native language and because the blog is focused to the spanish-speaking community, we want to give power to the \u0026ldquo;Hispano\u0026rdquo; community due many of the articles, books, tutorials and Internet contet about technology is written in english, so we want to get close to those people that have not the chance to get in contact or learn english.\nI want to invite you to see our Blog and let us your comments if you like, you have doubts or you want to improve the content. Besides to invite you to visit and read the blog I also want to announce that I\u0026rsquo;ll been adding here a short description in english of the posts I write, due I know they could be of your interest, it is possible that you could be also interested in learn spanish :)\n","date":"2017-04-27T00:00:00Z","image":"https://marcestarlet.github.io/p/techwo-blog-project/techwo-blog_hu4ebb17a02e472e11d6d8fcdb6076c7d1_490540_120x120_fill_box_smart1_3.png","permalink":"https://marcestarlet.github.io/p/techwo-blog-project/","title":"Techwo Blog Project"},{"content":"Now a days I\u0026rsquo;ve heard that EVERYBODY must know how to program, due the technology is everywhere, due your abilities and skills will be developed in a creative way.\nI think all of these arguments are valid and I really agreed them, but I believe that be a programmer is now more than just know how to program. If everybody learn how to program, I don\u0026rsquo;t think all become into programmers, the evolution of the software is turning the meaning into a more complex and complete definition. The idea to teach the kids about programming is in mi humble opinion, to let them know other way to solve problems using technology, prepare the minds of the new generations with the civic knowledge about how to improve the world, and for obvious reasons they won\u0026rsquo;t be afraid to get in touch with technology.\nIn a few words:\n \u0026ldquo;use the technology in your favor and in the others favor\u0026rdquo;\n So, if everybody will know how to program, but no all will become into programmers \u0026hellip;\nWho the hell will be a programmer? There are many definitions to describe what a programmer is, and the opinion of every programmer will be different so, I\u0026rsquo;m going to mention the things I believe are the most common and also I\u0026rsquo;m going to add mine.\nFirst of all, a programmer is a person who writes software, who use a programming language to develop professional programs that solve problems or improve manual process. I did emphasis in the word professional because I believed this will be the differentiator between who will know how to program and who will be a programmer. When the people change their code from \u0026ldquo;garage code\u0026rdquo; into a \u0026ldquo;professional code\u0026rdquo;, the programmer inside them, will have born.\nFor professional, I mean that their code will have the following characteristics:\n It\u0026rsquo;ll be complete  Completely functional (it works) Usable and useful Will accomplish the requirement(s) Will solve the problem in the better way (relative)   Will follow the best practices of the language in which it was written Will be tested (at least unit test)  Unit tests Integration tests   The code will be documented The code will be maintainable Will be collaborative  It is possible that they, will just write a few lines of code at the begining, but it won\u0026rsquo;t matter the number of lines, what will really matter, is that those lines will be well written since the beginning, because their formation as a programmer will tell them, that they do not only know how to program, it will tell them that they know the best way of how to program, or the best way of write code to do it professional and collaborative.\nThere are many opinios of how a programmer should be, this my opinion of the near future of the programmers and how I believe this profesion will turn into.\n","date":"2016-10-31T00:00:00Z","permalink":"https://marcestarlet.github.io/p/be-a-programmer-in-the-near-future/","title":"Be A Programmer In The Near Future"},{"content":"MQTT - Concepts \u0026amp; Usage The last part of this serie of posts about MQTT will cover some concepts about the protocol that essentialy will show us the boundaries of the protocol and how it handles the connections between clients and the broker.\nConnection Let\u0026rsquo;s start by defining the MQTT Connection. The connection initiates when a client sends a CONNECT message to the broker, then the broker responds with a CONNACK and a status code.\n MQTT Connection \nOnce the connections is established the broker will keep the connection until the client send a disconnect command or it losses the connection.\nThe CONNECT message include some information relative to an implementer of a MQTT library than the users that will use the library, here I\u0026rsquo;ll present to you the basic information relevant for the users.\n clientId The clientId is an identifier for each MQTT Client, this means that should be unique for each client connected to the broker indicating that it must keep the state for that client. Since MQTT version 3.1.1, it is possible to connect without a clientId so the broker won\u0026rsquo;t keep the state. If you use clientId you should set cleanSession to true, otherwise the connection will be refused. cleanSession The cleanSession flag indicates to the broker whether the client wants to establish a persistent session or not. If cleanSession is set to false, it means that the broker will stores all the subscriptions of the client as well as all the messages that do not arrived to the client as long as the QoS has been defined as 1 o 2. If cleanSession is set to true, the broker won\u0026rsquo;t store anything for the client, non the subscriptions neither the missed messages. username/password (optional) The username and password are used for authentication and authorization. It is recommended to encrypt the password. keepAlive The keepAlive is a time interval, the clients commits to by sending regular PING Request messages to the broker. The broker response with PING Response and this mechanism will allow both sides to determine if the other one is still alive and reachable.  When the broker obtains the CONNECT it responds with a CONNACK message that only contains two data entries.\n sessionPresent This flag indicates to the client wheter the broker has a persistent session or not. If the client in a previous connection set the cleanSession to false then this flag is true, otherwise is false. returnCode This flags lets the client know if the connection attemp was successfull or not, and if not, it indicates what the issue is.  Publish The publish action allows a client to send messages to a topic destination in different modes, but always with a payload, and due MQTT is a data agnostic, you can set to the payload the data you want for the case you need. The publish message have some attributes, listed bellow the most important:\n Topic Name, the name of the topic destination to publish in the broker QoS, the \u0026ldquo;Quality of Service\u0026rdquo; in which you want to send a message. It is used to define the guarantee of a message. The possible values are 0, 1 or 2. See more about the QoS in the next section. Retain Flag, this flag instructs the broker to retain the last message sent for those new subscribers in order to receive the retained message in a new conenction to the broker. This could be usefull if you have a notification for new subscribers. Payload, is the content of the message. As commented before MQTT is data agnostic so you can send any kind of message (image, binary, text). Packed ID, is a unique identifier between the client and brokre that identifies the message during the message flow. Dup Flag, indicates that a message is duplicate because the last message sent was not acknowledged, so the message will be resent. This flag is taking in account when QoS 1 or 2.  Each publisher is responsible of the send of the message to the broker, once the broker receives the message it is now responsible to publish the message to the subscribers.\n Publish \nHere the code of a MQTT Client - Publisher using the Paho API\nMqttClient samplePublisher = null; try { // set default memory persistence in case QoS is 1 or 2  MemoryPersistence persistence = new MemoryPersistence(); // create new MQTT Client using URI, CLientID and persistence  samplePublisher = new MqttClient(getUri(), getClientId(), persistence); // create MQTT Options to set the connection attributes  MqttConnectOptions options = new MqttConnectOptions(); // default cleanSession is set to true to indicate the broker to don\u0026#39;t keep session  // change to false if you want the broke keep a session  options.setCleanSession(true); logger.info(\u0026#34;Connecting to: {}\u0026#34;, getUri()); // establish a connection  // a CONNECT is sent and the broker should respond with a CONNACK  samplePublisher.connect(options); // create new MQTT message  MqttMessage message = new MqttMessage(); // the payload is the content of a message  message.setPayload(getPayload().getBytes()); logger.info(\u0026#34;Publishing message {} to {} topic\u0026#34;, getPayload(), getTopic()); // publish the message to the Topic indicated  samplePublisher.publish(getTopic(), message); logger.info(\u0026#34;Message sent, disconnecting client\u0026#34;); // disconnect  samplePublisher.disconnect(); } catch (MqttException e) { // handle exception  logger.error(\u0026#34;Error while publishing\u0026#34;); logger.error(\u0026#34;Reason \u0026#34;, e.getReasonCode()); logger.error(\u0026#34;Message \u0026#34;, e.getMessage()); logger.error(\u0026#34;Localized Message \u0026#34;, e.getLocalizedMessage()); logger.error(\u0026#34;Cause \u0026#34;, e.getCause()); logger.error(\u0026#34;Exception \u0026#34;, e); logger.error(\u0026#34;StackTrace\u0026#34;, (Object[])e.getStackTrace()); } Complete code\nSubscribe A subscription is when a MQTT client susbcribes to a Topic in a Broker with a specific QoS, in order to receive the messages that a puslisher send to the topic where is subscribed. A subscription consists of a SUBSCRIBE message that has a packed identifier and a list of subscriptions as attributes.\n Packed ID, is a unique identifier between the client and brokre that identifies the message during the message flow. List of Subscriptions, contains an indetermined subscriptions that are formed of Topic and QoS pairs. The Topic attribute could be a wildcard that makes the client able to subscribe to some topic patterns.  Then, the broker responds with a SUBACK message that has the same Packed Identifiers as the SUBSCRIBE message and a list of return codes.\nThe SUBACK contains a return code per each subscription in the SUBSCRIBE message. When a topic is overlapped, then the highest QoS is taken for the delivering of the message.\n Subscribe \nHere the code of a MQTT Client - Subscriber using the Paho API\n// the class must implement MqttCallback  MqttClient sampleSubscriber = null; try { // set default memory persistence in case QoS is 1 or 2  MemoryPersistence persistence = new MemoryPersistence(); // create new MQTT Client using URI, CLientID and persistence  sampleSubscriber = new MqttClient(getUri(), getClientId(), persistence); // create MQTT Options to set the connection attributes  MqttConnectOptions options = new MqttConnectOptions(); // default cleanSession is set to true to indicate the broker to don\u0026#39;t keep session  // change to false if you want the broke keep a session  options.setCleanSession(true); // set 30 sec of keepAlive  options.setKeepAliveInterval(30); logger.info(\u0026#34;Connecting to: {}\u0026#34;, getUri()); // establish a connection  // a CONNECT is sent and the broker should respond with a CONNACK  sampleSubscriber.connect(options); // set an asynchronous receive  sampleSubscriber.setCallback(this); // subscribe to the Topic and QoS indicated  sampleSubscriber.subscribe(getTopic(), getQos()); logger.info(\u0026#34;Subscribed and waiting ...\u0026#34;); } catch (MqttException e) { // handle exception  logger.error(\u0026#34;Error while susbcribing\u0026#34;); logger.error(\u0026#34;Reason \u0026#34;, e.getReasonCode()); logger.error(\u0026#34;Message \u0026#34;, e.getMessage()); logger.error(\u0026#34;Localized Message \u0026#34;, e.getLocalizedMessage()); logger.error(\u0026#34;Cause \u0026#34;, e.getCause()); logger.error(\u0026#34;Exception \u0026#34;, e); logger.error(\u0026#34;StackTrace\u0026#34;, (Object[])e.getStackTrace()); } @Override public void messageArrived(String topic, MqttMessage message) throws Exception { logger.info(\u0026#34;Message arrived: {}\u0026#34;, new String(message.getPayload()));\t} Complete code\n","date":"2016-04-20T00:00:00Z","permalink":"https://marcestarlet.github.io/p/mqtt-concepts-usage/","title":"MQTT - Concepts \u0026 Usage"},{"content":"What \u0026ldquo;Messaging System\u0026rdquo; means? The Messaging Systems exist since some years ago but they\u0026rsquo;re not so popular as other kind of systems.\nA Messaging is usually use in an enterprise environment. An enterprise has many different applications working independently that have been built using different languages and platforms, if the enterprise needs to communicate them by sharing data and process in a diligent way, How the enterprise can do this?\nUsing Messaging Messaging allows the enterprise to share data from applications that have been built in different platforms and uses different kind of data by transforming the data in a common customized or not customized format and transferring the packed data between the applications. In a reliably, asynchronously, frequent and immediate transfer way, a Messaging System improves the enterprise communication.\nMessaging makes applications loosely coupled and with an asynchronous sending, the applications do not need to be running at the same time in ordert to transfer data, so this does the enterprise more reliable. Messaging delegtes \u0026ldquo;messagging systems\u0026rdquo; the responsibility of transfer the data between applications, so the applications do not need to worry about how the data is transfered but they worry about what data shold be transfer.\n Messaging \nIn order to transfer the data from different applications an EMS is needed.\nFrom Wikipedia article a EMS is:\n An EMS (Enterprise Messaging System) is a set of published enterprise-wide standards that allows organizations to send semantically precise messages between computer systems. EMS systems promote loosely coupled architectures that allow changes in the formats of messages to have minimum impact on message subscribers. EMS systems are facilitated by the use of structured messages (such as using XML or JSON), and appropriate protocols, such as DDS, MSMQ, AMQP or SOAP with web services.\n So at the end, a MOM (Message-Oriented Middleware) is required to support messaging in distributed systems. This software is specialized about communication, a MOM provides transforming, standardized protocols, communication routes (channels, pipes, etc.), a Message broker, and the APIs required to connect with.\nA robust MOM it is not always necessary, so far for many of the current systems that pretend to be simple but powerful, an answer to the new lightweight demands a Message Broker it is enough to cover the message communication for the enterprise.\nMessage Broker From Wikipedia article:\n A Message Broker is an intermediary program module that translates a message from the formal messaging protocol of the sender to the formal messaging protocol of the receiver.\n  A message broker is an architectural pattern for message validation, transformation and routing. It mediates communication amongst applications, minimizing the mutual awareness that applications should have of each other in order to be able to exchange messages, effectively implementing decoupling.\n  The purpose of a broker is to take incoming messages from applications and perform some action on them. The following are examples of actions that might be taken in by the broker:\n   Route messages to one or more of many destinations Transform messages to an alternative representation Perform message aggregation, decomposing messages into multiple messages and sending them to their destination, then recomposing the responses into one message to return to the user Interact with an external repository to augment a message or store it Invoke Web services to retrieve data Respond to events or errors Provide content and topic-based message routing using the publish–subscribe pattern    Message Broker \nThese are some of the most popular Message Brokers: Apache ActiveMQ, RabbitMQ, HiveMQ, Apache Kafka.\nActiveMQ Message Broker example code\nWhere a Messaging Systems should be used? As many of the systems and software solutions you can\u0026rsquo;t apply the Messaging System anywhere, but there are some specific scenarios where it should be use in order to improve the communication. The Messaging Systems should be used:\n In an enterprise that necessary require a reliable communication between applications. In distributed systems that wants to communicate data from different endpoints. When have different applications that only must to be worried about what data will be transferred and don\u0026rsquo;t care how it is transferred.  Some examples where a Messaging System is used: Apache TomEE, Eclipse, Whatsapp, etc.\n","date":"2016-04-17T00:00:00Z","permalink":"https://marcestarlet.github.io/p/messaging-systems/","title":"Messaging Systems"},{"content":"MQTT - The protocol Now that you know the reason of the existence of MQTT and where to use it, you can learn how it works and then how to use it.\n My philosophy: Only when we know the reason of why a technology exists and where we can apply it, the technology becomes real, otherwise does not exists.\n Now some context, take it from Wikipedia the definition of protocol: In telecommunications, a communications protocol is a system of rules that allow two or more entities of a communications system to transmit information via any kind of variation of a physical quantity. These are the rules or standard that defines the syntax, semantics and synchronization of communication and possible error recovery methods. Protocols may be implemented by hardware, software, or a combination of both.\nThe MQTT protocol is based on top of TCP/IP and both client and broker need to have a TCP/IP stack.\nMQTT Elements  Publish/Subscriber Client Broker (Server)  Publish/Subscriber The publish/subscribe pattern (pub/sub) is an alternative to the traditional client-server model, where a client communicates directly with an endpoint. However, Pub/Sub decouples a client, who is sending a particular message (called publisher) from another client (or more clients), who is receiving the message (called subscriber). This means that the publisher and subscriber don’t know about the existence of one another. There is a third component, called broker, which is known by both the publisher and subscriber, which filters all incoming messages and distributes them accordingly.\nAdvantages of this pattern:\n Decoupling of the clients, publishers and receivers, do not need to know about each others, do not need to be running at the same time, and the operations on both components do not affect the other. Message filtering is the ability that pub/sub defines so the receivers do only receive the messages they are interested in. Scalability. Can be highly parallelized and processed event-driven.  MQTT takes advantages of all of these characterístics of the pub/sub pattern.\n Pub/Sub example \nThis fragment was taken from the HiveMQ MQTT blog documentation HiveMQ Pub/Sub.\nClient As we have explained in the previous section we can infer that a client can be both a publisher or a subscriber acting under the different purposes they have, or be both at the same time. A publisher is the client destined to accomplish the task of send messages to the MQTT Broker, so then, the subscriber is charged to subscribe to the broker and receive the messages that is interested in.\nTherefore, a client is any device using the MQTT library and executes the corresponding to connect to a MQTT broker, through a network.\nThe MQTT protocol has many library implementations in most of the programming languages such as Java, Android, Arduino, C, C++, C#, Go, iOS, JavaScript, .NET.\nBroker The Broker is the heart of the protocol, it is the component that makes the protocol real. The Broker is in charge of establish connections with all clients, receive all the messages, filter and deliver them to the corresponding interested subscribers. Besides, it persists the messages needed, keeps sessions with the clients, security by supporting authorization and authentication, etc. As it is responsible of communication between clients it must support failover scenarios to recover itself, should be scalable as well as easy to integrate in backend systems.\nThe Clients connect to the Broker and the broker connects the clients each other.\nSome Brokers that implements MQTT are:\n  ActiveMQ\n  Apache Apollo\n  HiveMQ\n  Mosquitto\n  Moquette\n  RabbitMQ\n  WebSpehreMQ\n  JBoss A-MQ\n  IBM Integration Bus\n  In the Next post of the MQTT protocol I\u0026rsquo;ll explain you the concepts of the protocol like: QoS, Session, Topics, Connections, MQTT Messages, etc. Also, we\u0026rsquo;ll see how to use the protocol by implementing some clients that will connect to a MQTT Broker.\n","date":"2016-01-21T00:00:00Z","permalink":"https://marcestarlet.github.io/p/mqtt-the-protocol/","title":"MQTT - The Protocol"},{"content":"INTRODUCTION What about MQTT? Have you heard about MQTT? Hope you have, but if you haven\u0026rsquo;t, don\u0026rsquo;t worry you\u0026rsquo;ll be hearing more about it in the next months since it\u0026rsquo;s becoming popular.\nMQTT is the most popular protocol used for IoT (internet of things) but don\u0026rsquo;t get confused, MQTT isn\u0026rsquo;t only for IoT, as it is a protocol it can be used in most of the communication situations, like TCP/IP does, but there are some great things that becomes MQTT special and unique to solve a communication problem.\nHistory MQTT was born in the IBM labs in 1999, when they faced a situation where they needed to save battery energy and use minimal bandwidth communication for a satellite connection. MQTT has a long story about its supposed acronym meanning, but what you should know about it, is: that the acronym does not exists anymore and you should only call it MQTT. Courious fact: I know about MQTT because of its acronym meanning that comes from an old IBM product called \u0026ldquo;MQ Series\u0026rdquo; that uses this \u0026ldquo;Telemetry Transport\u0026rdquo; protocol.\nWell, after some history we can pass to a more excited section that defines to us the MQTT protocol.\nWhat really is MQTT? MQTT is a lightweightm, open, simple and easy to implement Client Server publish/subscribe messaging transport protocol.\n\u0026ldquo;lightweight\u0026rdquo; because is binary and it has only minimal packet overhead. \u0026ldquo;open\u0026rdquo; because since it became standard, the OASIS open organization took it under their tutelage. \u0026ldquo;simple\u0026rdquo; because is extremely easy to implement in the client side.\nTherfore, it was created to run over constrained devices with limited resources.\nTa, Tan! Yep, these are the things that makes MQTT special. Think on these 3 things, related to the constrained and limited devices. First, the devices, what kind of devices are limited? a Microwave, a Refrigerator, a Watch, etc., ok then start thinking, why you want to communicate your microwave or refrigerator to other devices more complex and less limited? Because we\u0026rsquo;re in the XXI century and we\u0026rsquo;re smart people and we\u0026rsquo;re programmers and someone has invented a lightweight and simple protocol to do that and taking in account all of these reasons, just because we want smart houses, smart cities and change the world, so please start thinking on this when you want to learn more about MQTT and you want to use it to solve a communication problem.\nIn the next post I\u0026rsquo;ll tell you more about the Client Server and publish/subscribe transport protocol.\n","date":"2016-01-14T00:00:00Z","permalink":"https://marcestarlet.github.io/p/mqtt-introduction/","title":"MQTT - Introduction"},{"content":"El comienzo/The begining Hola/Hi\nMi nombre es Marcela Sena conocida como MarceStarlet, tengo 28 años, soy Ingeniero de Software y vivo en Guadalajara, Jal., México; les doy la bienvenida a éste mi nuevo blog de programación/conceptos/tecnologías/herramientas/tendencias/ciencias computacionales/etc., esperando sea de su agrado.\nLa idea de este blog es compartirles lo que sé, lo que estoy aprendiendo, y lo que me gustaría aprender, todo relacionado con las ciencias computacionales. El reto para mi es escribirles frecuentemente; al menos una vez al mes encontrarán un post.\nAhora les hablaré sobre lo que estoy usando para bloggear, les presento a \u0026ldquo;hugo\u0026rdquo;, un framework de propósito general para construir websites, y por website técnicamente concluimos que es un generador de sitios estáticos. Enfocado a la sencillez y rendimiento, está programado en \u0026ldquo;go\u0026rdquo; y es multiplataforma (Win, Mac, Linux). Este framework me lo presentó uno de mis ingenieros favoritos en todo el mundo: \u0026ldquo;Juan Sandoval\u0026rdquo;, y ahora se los presento yo a ustedes. Si quieren saber más sobre hugo, clic hugo.\nAdemás, les comento de antemano que estaré bloggeando en inglés para que el blog tenga más alcance.\nGracias\n/\nMy name is Marcela Sena well known as MarceStarlet, I\u0026rsquo;m 28 years old, I\u0026rsquo;m a Software Engineer and I live in Guadalajara, Jal., Mexico, I welcome you to my new blog about programming/concepts/technologies/tools/computer science/etc., hoping that you will enjoy.\nThe main idea of this blog is sharing what I know, what I\u0026rsquo;m learning, and what I want to learn, all related to computer science. The challenge for me is write for you as frequently as I can; at least once per month you will find a post here.\nNow I\u0026rsquo;m going to talk about what I\u0026rsquo;m using for blogging, let me introduce you to \u0026ldquo;hugo\u0026rdquo;, a general-purpose website framework, and for website we can technically conclude that is a static site generator. Focused in simplicity and performance, it was programmed in \u0026ldquo;go\u0026rdquo;, and it is cross platform (Win, Mac, Linux). This framework has been introduced to me by one of my favorite Engineers in the world: \u0026ldquo;Juan Sandoval\u0026rdquo;, and now I\u0026rsquo;m introducing it to you. If you want to know a little bit more about hugo, click hugo.\nAlso, I tell you in advance that I\u0026rsquo;ll be blogging in english to have more scope.\nThanks\n","date":"2016-01-14T00:00:00Z","permalink":"https://marcestarlet.github.io/p/welcome-2016/","title":"Welcome 2016"}]